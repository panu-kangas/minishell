char *readline (const char *prompt);

readline will read a line from the terminal and return it, using prompt as a prompt.If prompt is NULL or the empty string, no prompt is issued.  The line returned is allocated with malloc(3); the caller must free it when finished.

void rl_clear_history (void):   Clear the history list by deleting all of the entries, in the same manner as the History library’s clear_history() function. This differs from clear_history because it frees private data Readline saves in the history list.

int rl_on_new_line (void):      Tell the update functions that we have moved onto a new (empty) line, usually after outputting a newline.

void rl_replace_line (const char *text, int clear_undo)     Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible. If clear_undo is non-zero, the undo list associated with the current line is cleared.

void rl_redisplay (void)
Change what’s displayed on the screen to reflect the current contents of rl_line_buffer.
add_history (line); If you want the user to be able to get at the line later, (with C-p for example), you must call add_history() to save the line away in a history list of such lines.

int chdir(const char *path);
chdir() changes the current working directory of the calling process to the directory specified in path.

char *getcwd(char buf[.size], size_t size);
The getcwd() function copies an absolute pathname of the current working directory to the array pointed to by buf, which is of length size. If the length of the absolute pathname of the current working directory, including the terminating null byte, exceeds size bytes, NULL is returned, and errno is set to ERANGE; an application should check for this error, and allocate a larger buffer if necessary.

int stat(const char *restrict pathname, struct stat *restrict statbuf);
stat() and fstatat() retrieve information about the file pointed to by pathname;

int lstat(const char *restrict pathname, struct stat *restrict statbuf);
lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns information about the link itself, not the file that the link refers to.

int fstat(int fd, struct stat *statbuf);
fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the file descriptor fd.

​​int unlink(const char *pathname);
unlink() deletes a name from the filesystem.  If that name was the last link to a file and no processes have the file open, the file is deleted and the space it was using is made available for reuse.

DIR *opendir(const char *name);
The opendir() function opens a directory stream corresponding to the directory name, and returns a pointer to the directory stream.  The stream is positioned at the first entry in the directory.

struct dirent *readdir(DIR *dirp);
The readdir() function returns a pointer to a dirent structure representing the next directory entry in the directory stream pointed to by dirp. It returns NULL on reaching the end of the directory stream or if an error occurred.

int closedir(DIR *dirp);
The closedir() function closes the directory stream associated with dirp.  A successful call to closedir() also closes the underlying file descriptor associated with dirp. The directory stream descriptor dirp is not available after this call.

int isatty(int fd);
The isatty() function tests whether fd is an open file descriptor referring to a terminal.


char *ttyname(int fd);
The function ttyname() returns a pointer to the null-terminated pathname of the terminal device that is open on the file descriptor fd, or NULL on error (for example, if fd is not connected to a terminal)

int ttyslot(void);
The legacy function ttyslot() returns the index of the current user's entry in some file.

int ioctl(int fd, unsigned long request, ...);
The ioctl() system call manipulates the underlying device parameters of special files.  In particular, many operating characteristics of character special files (e.g., terminals) may be controlled with ioctl() requests.  The argument fd must be an open file descriptor.

char *getenv(const char *name);
The getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string.

int tcgetattr(int fd, struct termios *termios_p);

int tcsetattr(int fd, int optional_actions,
              const struct termios *termios_p);
get and set terminal attributes
The termios functions describe a general terminal interface that is provided to control asynchronous communications ports.






These routines are included as a conversion aid for programs that use the termcap library. Their parameters are the same and the routines are emulated using the terminfo database. Thus, they can only be used to query the capabilities of entries for which a terminfo entry has been compiled.

int tgetent(char *bp, const char *name);
The tgetent routine loads the entry for name. It returns 1 on success, 0 if there is no such entry, and -1 if the terminfo database could not be found. The emulation ignores the buffer pointer bp.

int tgetflag(char *id);
The tgetflag routine gets the boolean entry for id, or zero if it is not available.

int tgetnum(char *id);
The tgetnum routine gets the numeric entry for id, or -1 if it is not available.

char *tgetstr(char *id, char **area);
The tgetstr routine returns the string entry for id, or zero if it is not available. Use tputs to output the returned string. The return value will also be copied to the buffer pointed to by area, and the area value will be updated to point past the null ending this value.

char *tgoto(const char *cap, int col, int row);
The tgoto routine instantiates the parameters into the given capability. The output from this routine is to be passed to tputs.

int tputs(const char *str, int affcnt, int (*putc)(int));
The tputs routine is described on the curs_terminfo(3X) manual page. It can retrieve capabilities by either termcap or terminfo name








